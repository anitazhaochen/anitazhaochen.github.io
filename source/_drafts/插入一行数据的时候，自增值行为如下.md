



### 插入一行数据的时候，自增值行为如下

1. 如果插入数据时id字段指定为0、null或未指定值，那么久把这个表当前的 AUTO_INCREMENT 值填到自增字段
2. 如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值

根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是X，当前的自增值是Y

	1. 如果 X < Y, 那么这个表的自增值不变
 	2. 如果 X>=Y，就需要把当前自增值修改为新的自增值。

新的自增值生成算法是： 从 auto_increment_offset 开始，以 auto_increment_increment 为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。

其中, auto_increment_offset 和 auto_increment_increment 是两个系统参数，分别用来表示自增的初始值和步长，默认都是1。

> 备注：在一些场景下，使用的就不全是默认值。比如，双 M 的准备结构里要求双写的时候，我们就可能会设置成 auto_increment_increment=2，让一个库的自增id都是奇数，另一个库的自增id都是偶数，避免两个库生成的主键发生冲突。



### 导致自增主键不连续的原因

1. 唯一键冲突，插入失败后，自增主键值已经更新，不会回退

2. 同样的，事务回滚也会产生类似的现象

   

### 为什么出现唯一键冲突或者回滚的时候，MySQL 没有把表t的自增值改回去呢？

其实 MySQL 这么设计是为了提高性能。在并发事务时，可能会因为回退操作而导致事务执行失败或者通过其他复杂的方法来保证回退以及重新生成自增key的正确性。可能需要对自增id加锁，并且需要等待上一个事务执行完成后，才能确定当前事物的自增id值，会大大降低并发度。

因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增id。也正因为这样，所以才只保证了自增id是递增的，但不保证是连续的。



自增id锁并不是一个事务所，而是每次申请完就马上释放，以便允许别的事务再申请。



### 自增锁的优化

MySQL5.0版本的时候，自增锁的范围是语句界别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束后才释放，显然，这样设计会影响并发度。

MySQL 5.1.22 版本引入了一个新策略，新增参数 innodb_autoinc_lock_mode ， 默认值为1.

	1. 这个参数的值被设置为0时，表示采用之前 MySQL 5.0 版本的策略，即语句执行结束后才释放锁
 	2. 这个参数的值被设置为1时：
      	1. 普通 insert 语句，自增锁在申请之后就马上释放
      	2. 类似 insert .... select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放
	3. 这个参数值设置为2时，所有的申请自增主键的动作都是申请后就释放锁。



默认设置为1的情况下，为什么 insert ... select 要使用语句级别的锁？为什么这个参数的默认值不是2？

答案是： 这么设计还是为了数据的一致性， 在原库执行的时候可能存在事物间交叉执行，导致自增id不连续，如果binlog 的格式是 statement 格式，会造成恢复出来的数据和主库的不一致。

所以这里建议为了提高并发度，将 innodb_autoinc_lock_mode 设置为2 并且，binlog 的格式改为 row 格式。

优化：

​	在执行批量插入的时候，在普通的 insert 语句里面包含多个 value 值的情况下，即使 innodb_autoinc_lock_mode 设置为1，也不会等语句执行完成才释放锁。因为这类语句在申请自增id的时候，是可以精确计算出需要多少个id的，然后一次性申请，申请完成后锁就可以释放了。

也就是说，批量插入数据的语句，之所以需要这么设置，是因为”不知道预先申请多少个id“。

既然预先不知道要申请多少个自增id，如果是需要一个申请一个的话，按照这个逻辑就需要重复n次。显然，这种申请自增id的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。

因此，对于批量插入数据的语句，MySQL 有一个批量申请自增id的策略：

	1. 语句执行过程中，第一次申请自增id，会分配1个
 	2. 1个用完后，这个语句第二次申请，会分配2个
 	3. 2个用完后，还是这个语句，第三次申请自增id，会分配4个
 	4. 依次类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。

这个也是出现主键id自增不连续的第三种原因。