一：

1. 

2. 计算机为什么要用补码？

   出于简化计算机基本电路的考虑，让加减法都只需要用加法电路实现。所以需要把减去一个正数或加上一个负数都用加上一个正数的方式来表示，于是在存储的时候，负数被直接存储成一种可以直接当成正数加的形式（正数不变，所以以后的讨论中有时候略去正数），这种形式就是补码

2. 计算机内部的存储结构？虚拟内存和物理内存的区别？

   [虚拟内存与物理内存的区别](https://blog.csdn.net/u012861978/article/details/53048077)

   寄存器、缓存、内存、硬盘、移动存储设备

3. TCP流量控制和拥塞控制？

   拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。

   流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。

   [TCP流量控制、拥塞控制](https://zhuanlan.zhihu.com/p/37379780)

4. Time_wait有什么用？

    ① 为尽最大可能的实现TCP这种全双工（full-duplex）连接的可靠释放  TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL。  假设最后一个ACK丢失了，被动关闭一方会重发它的FIN。主动关闭一方必须维持一个有效状态信息（TIMEWAIT状态下维持），以便能够重发ACK。如果主动关闭的socket不维持这种状态而进入CLOSED状态，那么主动关闭的socket在处于CLOSED状态时，接收到FIN后将会响应一个RST。被动关闭一方接收到RST后会认为出错了。

   ② 为使旧的数据包在网络因过期而消失，以防止lost duplicate对后续新建正常链接的传输造成破坏。  有足够的时间让这个连接不会跟后面的连接混在一起，即，允许老的重复报文段在网络中消逝（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。  *TCP报文段可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个 原来的迷途分节就称为lost duplicate。在关闭一个TCP连接后，马上又重新建立起一个相同的IP地址和端口之间的TCP连接，后一个连接被称为前一个连接的化身 （incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。为了避免这个情况*，**TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时候，来自连接先前化身的重复报文段已经在网络中消逝**。

   [详细](https://cloud.tencent.com/developer/article/1152648)

   [谈谈TCP中的TIME_WAIT](https://blog.csdn.net/jewes/article/details/52654997)

5. 多进程和多线程的区别

   [多进程和多线程的区别](https://blog.csdn.net/linraise/article/details/12979473)

6. 随机数生成器（如何利用rand(1,8)实现随机生成1-5）

   ```C
   int rand10()
   {
       int n= 49;
       while (n>4){
           n=7*(rand7()-1)+rand7();
       }
       return n%10+1;
   }
   ```

   [随机数生成器](https://blog.csdn.net/yiqiangeliyou/article/details/46823595)

9. 手撕堆排



4、 同步IO和异步IO



5、 进程和线程的区别，创建线程和进程的开销指什么



7、 什么是面向对象



6、 死锁及如何避免

[死锁及其解决方案（避免、预防、检测）](https://blog.csdn.net/yyf_it/article/details/52412071)



10、求数组的中位数。数组由一个升序数组翻转形成，如1 2 3 4 5 6 7可以从5处翻转，形成5 6 7 1 2 3 4，求5 6 7 1 2 3 4的中位数。要求时间复杂度低于O(n)。



9、 设计题：设计一个购物车，给出应该有哪些数据表，每个表包含哪些字段



4、索引的原理？



5、B+树原理，为什么索引用B+树



7、数据库优化的一些策略

[数据库性能优化策略](https://blog.csdn.net/u013628152/article/details/51835121)



5.你了解查找树吗，手撕代码，如何判断一个树是否符合查找树的规则



4.进程间有哪些通信方式，如果有两个进程，一个进程执行一半要求另一个进程终止，该如何操作



二：

3、 InnoDB的索引类型

[从认识索引到理解索引「索引优化」](https://juejin.im/entry/5bbfe5b15188255c94465943)	

4、 B树和B+树的区别



5、 事务的四个隔离级别



6、 拥塞控制及对应方法的使用场景



7、session和cookie的区别



8、 设计题：设计一个任务定时器，给定时间和任务，到时间了自动执行对应的任务。



9、 堆里面如何控制并发安全

1. 如何改进UDP的不可靠传输，保证数据有序性？

​         UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。

​         传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。

​         实现确认机制、重传机制、窗口确认机制。

​         如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：

​         发送：包的分片、包确认、包的重发

​         接收：包的调序、包的序号确认

​         目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。

​	[udp如何实现可靠性传输？](http://www.voidcn.com/article/p-rjpaxhzo-bhh.html)

2. TCP三次握手和四次挥手的描述

3. 一致性哈希了解么？
4. 进程间的通信，文件通信了解过么？线程间共享的有哪些东西？

5. 算法题：一个链表，奇数位升序，偶数位降序，如何整体排成升序？

6. 算法题：千万级别的数据量，实现队列FIFO，如何设计数据结构节省内存空间（数据+链表）



三：

2. 问哪个项目最有收获，具体讲内容
3. Oracle高可用集群的共享存储怎么实现？

4. Redis和数据库一致性怎么实现？

5. 手撕数据库连接池（质疑我没有考虑高并发时的同步和效率问题）