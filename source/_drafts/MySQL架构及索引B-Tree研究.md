---
title: mysql架构及索引B+Tree原理分析
date: 2018-3-27 01:17:07
tags: [mysql, arch]
category: 数据库
---

### 



## MySQL 索引

索引用于快速查找具有特定值得行。如果没有索引，MySQL必须从第一行开始，通过遍历整个表来进行查找，表越大，话费的时间越多。如果表中有相关列的索引，MySQL可以快速确定要在数据文件中查找的位置，而不必查看所有数据，这比顺序读取每一行要快得多。

大多数 MySQL索引(主键、唯一索引、普通索引、全文索引)存储在 B树。

## mysql架构图简介

首先是一张官方给的 MySQL 架构图：

![image-20181012102719852](/images/image-20181012102719852.png)

MySQL 是基于单进程多线程。


用户连接：连接线程，支持长短连接    

MySql 线程池：Connection Pool
包含： Authentication 、Thread Reuse、Connection Limits、Check Memory、Caches
<!-- more -->

SQL 接口 SQL interface 
分析语句

Parser 解析：
解析语句，检测用户是否有权限执行某些语句

Optimizer 检查多条路径，根据统计数据选择最低开销执行 （优化查询）

Caches & Buffers

MySQL 插件式引擎，可以任意切换
如： MyISAM、InnoDB、NDB、Archive、Memory、Federate 等等引擎

MySQL 数据文件类型

​	数据文件、索引文件

​	重做日志、撤销日志、二进制日志、错误日志、查询日志、慢查询日志、中继日志

Management Service & Utilitles 管理服务及工具

​	备份恢复工具、安全工具、集群服务、应用工具、管理配置工具、迁移工具

索引管理：
​	 按特定数据结构存储的数据

索引类型：
​	聚集索引、非聚集索引：数据是否与索引存储在一起
​	主键索引、辅助索引
​    	稠密索引、稀疏索引：是否索引了每一个数据项
​    	B（Balance）+TREE、HASH（键值对）、R-TREE
​    	简单索引、组合索引
​    	覆盖索引：不用查找源数据，直接就能就能找到数据，如：名字和课程索引，查到课程就可以知道名字。
​    	左前缀索引： 从左到右抽取特定大小数据进行索引。这样就会导致一个问题，通过查询中间出现abc的语句， like %abc% 查询索引就失效了，最好不要加左%号

管理索引的途径：

​	创建索引：创建表时指定

​	创建或者删除索引：修改表的命令

使用EXPLIAN:

​	  查看查询的过程` EXEPLIAN select * from table where  xx = xx\G` 可以查看查询过程。

视图：VIEW

虚表：
​	视图中的数据事实上存储于基表中，因此，其修改也会针对基表实现，其修改操作受基表限制

mysql优化： 

​	使用一种sql语句风格进行查询， 因为在查询的时候，会对 查询语句做一次hash， hash 是区分大小写的。

​	查询**表**扫描转化为**索引**扫描 

联合索引：

​	我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引。



> 如果问 MySQL 的索引结构，曾经是B-Tree现在是B+Tree。（MySQL官方文档写的是B-Tree）B+TREE 是 B-TREE 的优化版本，提高了很多性能。在范围查询和磁盘 I/O 做了优化，并且可以很方便的进行遍历。

MyISAM 是 MySQL 5.1 之前版本默认的存储引擎，从5.5之后，InnoDB开始成为 MySQL 默认的存储引擎。

MyISAM 使用 B-Tree 实现主键索引、唯一索引和非主键索引。

InnoDB **中非主键索引使用的是 B-Tree 数据结构(不一定正确，有待探索，官方文档一律使用b-tree说明。)**，而主键索引使用的是 B+Tree。

### 为什么使用 B+Tree 作为索引

MySQL官方对索引的定义为：索引是数据结构。

为了查询数据的速度能尽可能的快，数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是[顺序查找](http://en.wikipedia.org/wiki/Linear_search)（linear search），这种复杂度为 O(n) 的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如[二分查找](http://en.wikipedia.org/wiki/Binary_search_algorithm)（binary search）、[二叉树查找](http://en.wikipedia.org/wiki/Binary_search_tree)（binary tree search）等。每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于[二叉查找树](http://en.wikipedia.org/wiki/Binary_search_tree)上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列数据都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构（通俗说就是从每一行数据中抽取出某个字段使用特定的数据结构组织在一起，然后指向原始数据。），这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

![image-20181012115520597](/images/image-20181012115520597.png)

上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含**索引键值**和一个指向对应**数据记录物理地址的指针**，这样就可以运用二叉查找在O(lgn)的复杂度内获取到相应数据。

虽然可以实现索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种[红黑树](http://en.wikipedia.org/wiki/Red-black_tree)（red-black tree）实现的。

### 为什么索引不用普通的二叉树实现

> 磁盘的 i/o 速度是内存的几百分分之一，磁盘 i/o 会消耗很大比例的时间。对于上面的问题，我是这么理解的，因为索引最终要存储在硬盘上，要设计一种减少磁盘 i/o 的数据结构来存储，而B-Tree就可以减少磁盘 i/o。
>

#### 索引一般存储在磁盘 & 红黑树一般出现在内存

一般来说，索引本身也很大，因此索引往往以**索引文件**的形式存储的**磁盘**上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。

而内存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的**距离**不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。

一次磁盘 I/O 请求（读/写）完成过程由三个动作组成：
​       1）寻道（时间）：磁头移动定位到指定磁道 
​       2）旋转延迟（时间）：等待指定扇区从磁头下旋转经过 
​       3）数据传输（时间）：数据在磁盘与内存之间的实际传输

因此在磁盘上读取扇区数据（一块数据）所需时间：

 `**T**i/o=**t**seek +**t**la + n ***t**wm`

tseek 为寻道时间

tla为旋转时间

twm 为传输时间

为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：

当一个数据被用到时，其附近的数据也通常会马上被使用。

程序运行期间所需要的数据通常比较集中。

由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。

> 我的理解： 数据库在加载磁盘 I/O 索引的时候，不一定会使用到 局部性原理 ，因为磁盘的数据本来就是随机存放的，并且索引的每一个节点就是一页。这里，局部性原理可以直接忽略。不影响我们讨论数据库索引的磁盘 I/O。

[磁盘原理非常详细](https://blog.csdn.net/hguisu/article/details/7408047)

数据库系统将一个节点的大小设为等于一个页，这样每个**节点**只需要一次 I/O 就可以完全载入。每次新建**节点**时，直接申请一个页的空间，这样就保证一个**节点**物理上也存储在一个页里，加之计算机存储分配都是按页对齐的（貌似意思就是数据存储分配单位是一页），就实现了一个 **节点** 只需一次 I/O (一个页里包含一个节点的所有数据) 。让树的变为多叉树，就会让树的高度降低。

> 当时学习的时候，搞不懂为什么一次分配一个页，并且这样也没有比二叉树好到哪去，反正每个节点都需要分配一个页。下面来解释一下：

![image-20181012154128592](/images/image-20181012154128592.png)

请注意：这里所说的节点，不是一个节点，而是一个块，有一堆节点。所以，自然与二叉树的单个节点不同，并且也会更加节省硬盘空间，更加紧凑。

一页能存储小节点的个数：

能存的最大小节点数=floor(pagesize/(keysize+datasize+pointsize))

floor 是向下取整的意思，如2.3向下取整就是2。

由于B+Tree内节点去掉了data域，因此可以拥有更大的可存储的小节点个数，树的高度更低，因此拥有更好的性能。

B-Tree 中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。

[MySQL 索引背后的数据结构及算法原理](https://www.kancloud.cn/kancloud/theory-of-mysql-index/41857)



## B-Tree 对比二叉树

每个节点中既要存索引信息，又要存其对应的数据，如果数据很大，那么当树的体量很大时，每次读到内存中的树的信息就会不太够。

B 树遍历整个树的过程和二叉树本质上是一样的，B树相对二叉树虽然提高了磁盘IO性能，但并没有解决遍历元素效率低下的问题。



## B+Tree 的对比 B-Tree

* B+Tree 的磁盘读写代价更低

  B+Tree 的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部             结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的           关键字也就越多。相对来说IO读写次数也就降低了。

* B+Tree 的数据信息遍历更加方便

  B+树只要遍历叶子节点就可以实现整棵树的遍历，而B树不支持这样的操作（或者说效率太低），而且在数据库中基于范围的查询是非常频繁的，所以数据库索引基本采用B+Tree。

* B+树的查询效率更加稳定

  由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。



## InnoDB

> 在 MySQL 8.0 中，InnoDB 是默认的 MySQL 存储引擎。除非您配置了其他默认的存储引擎，否则执行 CREATE TABLE 不带 ENGINE= 的创建表语句的时候，会创建一个 InnoDB 表。

特点：

* 操作遵循 ACID 模型，具有 提交、回滚、崩溃恢复功能和事务
* 行级锁，提高多用户并发性和性能。
* InnoDB 基于主键优化查询。每个 InnoDB 表都有一个称为 [聚集索引](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index) 的主键索引，改索引组织数据以最小化主键查找的 I/O。[聚集索引和二级索引](https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html)
* 维护数据完整性， InnoDB 支持 FOREIGN KEY 约束。

### 功能

| 特征                                                      | 支持                                                         |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| **B树索引**                                               | 是                                                           |
| **备份/时间点恢复**（在服务器中而不是在存储引擎中实现。） | 是                                                           |
| **集群数据库支持**                                        | 没有                                                         |
| **聚集索引**                                              | 是                                                           |
| **压缩数据**                                              | 是                                                           |
| **资料快取**                                              | 是                                                           |
| **加密数据**                                              | 是（通过加密功能在服务器中实现；在MySQL 5.7和更高版本中，支持静态数据表空间加密。） |
| **外键支持**                                              | 是                                                           |
| **全文搜索索引**                                          | 是（MySQL 5.6和更高版本提供InnoDB对FULLTEXT索引的支持。）    |
| **地理空间数据类型支持**                                  | 是                                                           |
| **地理空间索引支持**                                      | 是（MySQL 5.7和更高版本提供InnoDB对地理空间索引的支持。）    |
| **哈希索引**                                              | 否（InnoDB在内部将哈希索引用于其自适应哈希索引功能。）       |
| **索引缓存**                                              | 是                                                           |
| **锁定粒度**                                              | 行                                                           |
| **MVCC**                                                  | 是                                                           |
| **复制支持**（在服务器中而不是在存储引擎中实现。）        | 是                                                           |
| **储存限制**                                              | 64TB                                                         |
| **T树索引**                                               | 没有                                                         |
| **交易次数**                                              | 是                                                           |
| **更新数据字典的统计信息**                                | 是                                                           |

摘自 MySQL 8.0 官方文档。



## InnoDB 索引的物理结构

* 聚集索引

  官方解释： 主键索引的 InnoDB 术语。表存储是基于主键列的值组织的，以加快涉及主键列的查询和排序。为了获得最佳性能，请根据性能要求最严格的查询仔细选择主键列。因为修改聚集索引的列是一项昂贵的操作，所以请选择很少更新或永远不会更新的祝列。

  简单来说： 一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。

  聚集索引确定表中数据的物理顺序。聚集索引类似于电话薄，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺讯，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话薄按姓氏和名字进行组织一样。

  ​		聚集索引对于哪些经常要搜索范围值得列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。

  > 例子：如果应用程序执行的一个查询经常检索某一个日期范围内的记录，则使用聚集索引可以迅速找到包含开始日期的行，然后检索表中响铃的行，直到到达结束日期。

  ​			如果丢从表中检索的数据进行排序时经常要用到这一列，则可以将该表在该列上聚集（物理排序），避免每次查询该列时都能进行排序，从而提高效率。

* 非聚集索引

  即：该索引的逻辑顺序与磁盘上行的物理存储顺序不同。

* 聚簇索引

  索引的叶子节点就是数据节点

* 非聚簇索引

  索引的叶子节点存储的仍然是索引节点。(指向真是数据的位置)

* [为索引页配置合并阈值](https://dev.mysql.com/doc/refman/8.0/en/index-page-merge-threshold.html) 如果 InnoDB索引页的填充因子下降到某个值，默认 50%，则 InnoDB 尝试收缩索引树以释放页面。

* 设置表空间页面大小： 支持大小64kb、32kb、16kb（默认）、8kb、4kb

  使用特定 InnoDB 页面大小的 MySQL 实例不能使用来自使用来自使用不同页面大小的实例的数据文件或日志文件。