---
title: 数组链表容器的一些问题
date: 2020-12-15 14:17:58
tags: [数据结构]
category: 数据结构
---

### 大多数编程语言中，数组要从0开始编号，而不是从1开始呢？

从数组存储的内存模型来看，“下标”最确切的定义应该是“偏移（offset）”。
如果用 a 来表示数组的首地址，a[0] 就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置，
所以计算a[k]的内存地址只需要用这个公式：
`a[k]_address = base_address + k * type_size`

但是如果数组从1开始计数，那我们计算数组元素a[k]就会变成为：
`a[k]_address = base_address + (k - 1) * type_size`

对于以上两个公司，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。

另一方面，可能也是历史原因造成的，C语言设计者用0开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的成本，因此沿用了从0开始计数的习惯。
<!--more -->
实际上，很多语言中数组也并不是从0开始计数的，比如 Matlab。

### 如何降低数组插入和删除对性能的影响？

普通做法，我们删除一个位置的数字，会移动其后面的数字到前面，如果删除的是第一个数，那么后面的数都需要移动一遍，正因为如此，数组的插入删除效率就很低。
不过我们可以在可以牺牲数组顺序性的前提下来优化，如删除第k个位置的数字，那么我们直接拿最后一个位置的数字和第k个位置的数字交换即可，然后标记数组长度。插入同理

### 数组和链表的区别？

链表更适合插入、删除，时间复杂度都是O（1）；数组适合查找，查找的时间复杂度为O（1）。
实际上，这种表述不准确。数组是适合查找操作，但是查找的时间复杂度并不是O（1）。即便是排序好的数组，使用二分查找，
时间复杂度也是O（logn）。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为O（1）。
另外：数组需要一块连续的内存空间来存储，而链表则不需要连续
链表的删除复杂度仅仅表示删除这个操作，不包含查找，如删除给定值的节点对应的链表操作的总时间复杂度为O（n）, 包含查找所用的时间。
数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。
数组的大小是固定的，链表可以支持动态扩容。
除此之外，如果你的代码对内存的使用非常苛刻，那么数组就更适合你。因为链表中的每个节点都需要消耗额外的空间去存储，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，
如果是 Java 语言，就有可能会导致频繁的 GC 。


### 容器能否完全替代数组？

针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。
举例 Java 中的 ArrayList，它跟数组相比的优势：
1. 可以将很多数组操作的细节封装起来。比如数组插入、删除时需要搬移其他数据等。另外，它还有一个优势，就是支持动态扩容。
虽然容器会自动帮我们扩容，但是扩容也会涉及内存申请和数据搬移，是比较耗时的。所以如果能事先确定好存储的数据大小，最好是在创建容器的时候事先指定数据大小。

作为高级语言编程，有些时候，使用数组会更合适：
1. 如 Java 中 ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而自动拆箱/装箱则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。

2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到容器提供的大部分方法，也可以直接使用数组。

3. 当要表示多为数组时，用数组往往会更加直观。

总结： 对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果是做一些非常底层的开发，比如开发网络框架，性能的优化要做到极致，这个时候数组就会优先于容器，成为首选。
