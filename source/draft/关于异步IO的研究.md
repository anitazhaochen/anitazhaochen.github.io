---
title: 异步 I/O 研究
date: 2018-09-27
tags: [linux, I/O]
category: linux

---



# 关于 select 、poll 、 epoll 的研究



## 异步 I/O

为什么要采用 异步 I/O ，想象这样一个场景，浏览器向服务器请求一个资源，如果采用同步方式，那么

```
同步方式：
// 消耗时间M
get image1
// 消耗时间N
get image2
// 获取完 image1 和 image2 所花时间为 M+N

异步方式：
// 消耗时间M
get image1
// 消耗时间N
get image2
// 获取完 image1 和 image2  所花时间为 max(M, N) 即M和N中间的较大值

```

如果网站资源很多，现在已经很常见，同步方式所花费的时间将是 A+B+C+....+....Z  而异步所花的时间取决于其中加载最慢的那一个资源。

* 不同 I/O 类型及其对 CPU 的开销

|  I/O 类型   | 花费的 CPU 时钟周期 |
| :---------: | :-----------------: |
| CUP一级缓存 |          3          |
| CPU二级缓存 |         14          |
|    内存     |         250         |
|    硬盘     |      41000000       |
|    网络     |      240000000      |

*此值取自： 《 深入浅出 NODE.JS 》*

从此图可以看出 I/O 是非常昂贵的。

如果要完成一组互不相关的任务，比如读取每一张图片：

​	单线程串行依次执行。

​	多线程并行完成。

要选择哪种去完成，取决于具体开销大小。 多线程的代价在于创建线程和执行期线程上下文切换的开销较大。在某些复杂的地方，多线程会存在资源竞争，状态同步的等等问题。



## 异步 I/O 操作系统

操作系统内核对于 I/O 只有两种方式：阻塞与非阻塞。在调用阻塞 I/O 时， 应用程序需要等待 I/O 完成后才返回结果。在此期间，此线程必须等到操作系统内核层面完成所有操作之后，调用才结束，才可以继续向后执行程序。

阻塞 I/O 造成的 CPU 等待 I/O ，浪费等待时间， CPU 的处理能力不能得到充分利用。为了提高性能， 内核提供了非阻塞 I/O。

非阻塞 I/O 调用之后会立即返回，这个立即返回到底什么意思呢，就是接下来 I/O 的事情就交给操作系统去做了，我们可以继续向后执行程序，当 I/O 准备好后，操作系统就会通知我们，我们就可以不需要等待直接去获取结果，这样性能提升是明显的。

但是，说是留给了操作系统去做，那么操作系统到底如何实现的呢？



## 操作系统异步 I/O 的实现

操作系统对计算机进行了抽象，所有输入输出设备抽象为文件。内核在进行文件 I/O 操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果要进行 I/O 调用，需要先打开文件描述符，然后再根据文件描述符去实现文件的数据读写。此处非阻塞 I/O 与阻塞 I/O 的区别在于阻塞 I/O 完成整个获取数据的过程，而非阻塞 I/O 则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取。



为了获取有效完整的数据，应用程序需要重复调用 I/O 操作来确认是否完成。这种重复调用判断操作是否完成的技术叫轮询。阻塞 I/O 造成 CPU 等待浪费，非阻塞带来 CPU 循环判断，对 CPU 的资源浪费。下面说一下 在 *unix 系统上面的一些轮询机制实现：



### select 

通过文件描述符上的时间状态来进行判断。

